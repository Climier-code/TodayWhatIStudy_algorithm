# Type Of CodingTest

> 코딩테스트를 유형화해보자(순서는 나동빈님의 유형분석 차트 차용 \_ 최다 빈출 순서로)

## 1. 구현

### 파싱, 해싱, 정렬, 시뮬레이션...

- **목적**: 문제 조건을 코드로 작성하여 잘 돌아가냐를 판단
- 코테에서 구현이란?
  - 문제 상황과 일대일 매칭
  - 보다 효율적으로 짜야하는 것을 목표
  - 최적화와 알고리즘 등 복잡한 코드도 이용할 수 있음

## 2. BFS, DFS

### 탐색

- **목적**: 특정 조건을 만족하는 상태를 찾기위해 적절한 코드를 작성할 수 있는가
- **특징**

  - BFS: Queue
  - DFS: Recursion(주로 이거 씀) or Stack

- `핵심`: **구현에 초점**

  - 부분 상태 탐색(위치 이동\_방향벡터, 수) -> 현재 상태 체크
  - 전체 상태 탐색(map) -> N차원 배열 조절
  - Flood Fill = 한붓그리기
  - 트리 순회

- **알고리즘에 초점**
  - 위상정렬
  - 최소신장트리
  - 최단거리

## 2.1. 방햑벡터

### 상하좌우, 대각선, 체스 이동..

- **목적**: 좌표선상에서 이동할 때 판단
- **특징**
  - 2차원 또는 3차원
  - 좌표를 생성한 뒤 DFS, BFS
  - x좌표 이동: `dx = [-1, 1, 0, 0]`, y좌표 이동: `dy = [0, 0, 1, -1]`

```python
dx, dy = [0,-1,0,1], [1,0,-1,0]

x+= dx['ENSW'.index(way)]
y+= dy['ENSW'.index(way)]

for i in range(4):
    dfs(x+dx[i], y+dy[i])
```

## 3. Greedy

### 탐욕 알고리즘

> 미래 예상 X, 지금 당장 좋은 것만 고르는 것

- 사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형
- **특징**
  - 가장 큰, 작은 순서대로
  - 주로 정렬 알고리즘과 같이 나옴
  - 문제 풀이를 위한 최소한의 아이디어를 도출 후 이것이 정당한지를 검토해야함.
  - 문제 유형을 파악하기 어렵다면 의심해봐야할 알고리즘

## 4. DP

### 동적계획법

- **목적**: 다음 상태를 저장하고, 사용하는 방식(메모이제이션)
- 무엇을 저장하고 어떻게 저장해야하는가..

- 푸는 순서

  1. 상태를 정의한다.(초기상태 초기배열 등등)
  2. 점화식을 찾는다(구한다.)
  3. 시간복잡도를 계산한다.
  4. 코딩한다.

- 푸는 방식

  - **Bottom-Up(반복문)**: 주로 초기화 후 데이터를 저장하면서 나가는 방식을 사용
  - Top-Down(재귀)
  - 시간복잡도는 수가 클 경우 재귀는 위험

- 사실상 점화식만 찾으면 간단해짐

## 5. 정렬

### 어쩌면 가장 기본적인..

- 유형
  - 시간복잡도가 널널X : QuickSort
  - 시간복잡도가 널널: list.sort()
  - 커스텀 정렬
- 보통은 `sort`, `sorted` 쓰면 다 풀림
- `sorted(정렬할 배열, reverse=True or False, key = lambda x:x[1]_ 정렬할 기준)`
  - 정렬할 기준이 생기면 (튜플이나 이중 배열에서 N번째 기준) 추가하면 쉬움
- 시간초과가 나오면 그때부터 quickSort

## 6. 이진탐색

### 선형탐색 중 시간복잡도가 낮음, 반으로 쪼개면서 탐색

- 가급적이면 코드를 외우기
- 순차정렬이 되었을 때만 사용가능
- 같은 숫자가 있는지 판단은 set()으로 판단
- 재귀 VS 반복문 : 맘대로 but 코드 간결은 반복문

## 7. 최단경로

> Greedy + Dynamic Programming

### 다익스트라 알고리즘

#### 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우

_한 도시에서 다른 도시까지의 최단거리_

- **순서**
  1. 출발노드를 설정한다.
  2. 최단 거리 테이블을 초기화한다.
  3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
  4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
  5. 3, 4 를 반복하여 가능한 모두 방문하도록 한다.
- **특징**
  - 주로 한 방향 그래프일 때가 많음
  - 최단 경로를 현재 저장된 거리와 비교 후 갱신(매번 가장 비용이 적은 노드를 선택)
  - 최소 힙 구조를 이용해 저장(`O(ElogV)`를 보장)
  - 도착한 해당 노드가 이미 처리됐다면 그냥 넘어감
  - 보통은 **최단 거리 테이블**, **그래프 연결정보를 담는 테이블**, **힙큐**를 생성하여 데이터를 넣고 빼는 작업을 진행
  - 저장 공간을 조절: `import sys` -> `input = sys.stdin.readline`

### 플로이드 워셜 알고리즘

#### 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우

_1번 노드에서 X를 거쳐 K로 가는 최단거리 (1->X 최단거리 + X->K 최단거리)_

- **특징**
  - 3중 반복문을 씀(O(N^3))
  - 2차원 리스트에서 모든 경우의 수를 고려하여 넣어짐
  - `graph[a][b] = min(graph[a][b], graph[a][k]+graph[k][b])`

## 8. 그래프이론

###
