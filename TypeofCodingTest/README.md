# Type Of CodingTest

> 코딩테스트를 유형화해보자(순서는 나동빈님의 유형분석 차트 차용 \_ 최다 빈출 순서로)

## 1. 구현

### 파싱, 해싱, 정렬, 시뮬레이션...

- **목적**: 문제 조건을 코드로 작성하여 잘 돌아가냐를 판단
- 코테에서 구현이란?
  - 문제 상황과 일대일 매칭
  - 보다 효율적으로 짜야하는 것을 목표
  - 최적화와 알고리즘 등 복잡한 코드도 이용할 수 있음

## 2. BFS, DFS

### 탐색

- **목적**: 특정 조건을 만족하는 상태를 찾기위해 적절한 코드를 작성할 수 있는가
- **특징**

  - BFS: Queue
  - DFS: Recursion(주로 이거 씀) or Stack

- `핵심`: **구현에 초점**

  - 부분 상태 탐색(위치 이동\_방향벡터, 수) -> 현재 상태 체크
  - 전체 상태 탐색(map) -> N차원 배열 조절
  - Flood Fill = 한붓그리기
  - 트리 순회

- **알고리즘에 초점**
  - 위상정렬
  - 최소신장트리
  - 최단거리

## 2.1. 방햑벡터

### 상하좌우, 대각선, 체스 이동..

- **목적**: 좌표선상에서 이동할 때 판단
- **특징**
  - 2차원 또는 3차원
  - 좌표를 생성한 뒤 DFS, BFS
  - x좌표 이동: `dx = [-1, 1, 0, 0]`, y좌표 이동: `dy = [0, 0, 1, -1]`

```python
dx, dy = [0,-1,0,1], [1,0,-1,0]

x+= dx['ENSW'.index(way)]
y+= dy['ENSW'.index(way)]

for i in range(4):
    dfs(x+dx[i], y+dy[i])
```

## 3. Greedy

### 탐욕 알고리즘

> 미래 예상 X, 지금 당장 좋은 것만 고르는 것

- 사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형
- **특징**
  - 가장 큰, 작은 순서대로
  - 주로 정렬 알고리즘과 같이 나옴
  - 문제 풀이를 위한 최소한의 아이디어를 도출 후 이것이 정당한지를 검토해야함.
  - 문제 유형을 파악하기 어렵다면 의심해봐야할 알고리즘

## 4. DP

### 동적계획법

- **목적**: 다음 상태를 저장하고, 사용하는 방식(메모이제이션)
- 무엇을 저장하고 어떻게 저장해야하는가..

- 푸는 순서

  1. 상태를 정의한다.(초기상태 초기배열 등등)
  2. 점화식을 찾는다(구한다.)
  3. 시간복잡도를 계산한다.
  4. 코딩한다.

- 푸는 방식
  - Top-Down(재귀)
  - Bottom-Up(반복문)
  - 시간복잡도는 수가 클 경우 재귀는 위험

## 5. 정렬

### 어쩌면 가장 기본적인..

- 유형
  - 시간복잡도가 널널X : QuickSort
  - 시간복잡도가 널널: list.sort()
  - 커스텀 정렬
- 보통은 `sort`, `sorted` 쓰면 다 풀림
- `sorted(정렬할 배열, reverse=True or False, key = lambda x:x[1]_ 정렬할 기준)`
  - 정렬할 기준이 생기면 (튜플이나 이중 배열에서 N번째 기준) 추가하면 쉬움
- 시간초과가 나오면 그때부터 quickSort

## 6. 이진탐색

### 선형탐색 중 시간복잡도가 낮음, 반으로 쪼개면서 탐색

- 가급적이면 코드를 외우기
- 순차정렬이 되었을 때만 사용가능
- 같은 숫자가 있는지 판단은 set()으로 판단
- 재귀 VS 반복문 : 맘대로 but 코드 간결은 반복문

## 7. 최단경로

### MST

## 8. 그래프이론

###
