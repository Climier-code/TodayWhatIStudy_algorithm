# Type Of CodingTest

> 코딩테스트를 유형화해보자(순서는 나동빈님의 유형분석 차트 차용 \_ 최다 빈출 순서로)

## 1. 구현

### 파싱, 해싱, 정렬, 시뮬레이션...

- **목적**: 문제 조건을 코드로 작성하여 잘 돌아가냐를 판단
- 코테에서 구현이란?
  - 문제 상황과 일대일 매칭
  - 보다 효율적으로 짜야하는 것을 목표
  - 최적화와 알고리즘 등 복잡한 코드도 이용할 수 있음

## 2. BFS, DFS

### 탐색

- **목적**: 특정 조건을 만족하는 상태를 찾기위해 적절한 코드를 작성할 수 있는가
- **특징**

  - BFS: Queue
  - DFS: Recursion(주로 이거 씀) or Stack

- `핵심`: **구현에 초점**

  - 부분 상태 탐색(위치 이동\_방향벡터, 수) -> 현재 상태 체크
  - 전체 상태 탐색(map) -> N차원 배열 조절
  - Flood Fill = 한붓그리기
  - 트리 순회

- **알고리즘에 초점**
  - 위상정렬
  - 최소신장트리
  - 최단거리

## 2.1. 방햑벡터

### 상하좌우, 대각선, 체스 이동..

- **목적**: 좌표선상에서 이동할 때 판단
- **특징**
  - 2차원 또는 3차원
  - 좌표를 생성한 뒤 DFS, BFS
  - x좌표 이동: `dx = [-1, 1, 0, 0]`, y좌표 이동: `dy = [0, 0, 1, -1]`

```python
dx, dy = [0,-1,0,1], [1,0,-1,0]

x+= dx['ENSW'.index(way)]
y+= dy['ENSW'.index(way)]

for i in range(4):
    dfs(x+dx[i], y+dy[i])
```

## 3. Greedy

### 탐욕 알고리즘

## 4. DP

### 동적계획법

- **목적**: 다음 상태를 저장하고, 사용하는 방식(메모이제이션)
- 무엇을 저장하고 어떻게 저장해야하는가..

- 푸는 순서

  1. 상태를 정의한다.(초기상태 초기배열 등등)
  2. 점화식을 찾는다(구한다.)
  3. 시간복잡도를 계산한다.
  4. 코딩한다.

- 푸는 방식
  - Top-Down(재귀)
  - Bottom-Up(반복문)
  - 시간복잡도는 수가 클 경우 재귀는 위험

## 5. 정렬

### 어쩌면 가장 기본적인..

- 유형
  - 시간복잡도가 널널X : QuickSort
  - 시간복잡도가 널널: list.sort()
  - 커스텀 정렬

## 6. 이진탐색

### 선형탐색 중 시간복잡도가 낮음

## 7. 최단경로

### MST

## 8. 그래프이론

###
